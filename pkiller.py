# Generated By Create New Playground (lmao) #
# Generated At: 2025-11-18 00:40:12.643340
# Author: Zane Reisbig

import ctypes
from ctypes import wintypes, WinDLL

from datetime import timedelta
import os
import subprocess
import re
import sys
from threading import Thread
import time

STILL_ACTIVE = 259


toKill = []
baud = 500


class UACHandler:
    ### shell32
    __shell32 = WinDLL("shell32")

    __ShellExecuteW = __shell32.ShellExecuteW
    __ShellExecuteW.argtypes = [
        wintypes.HANDLE,
        wintypes.LPCWSTR,
        wintypes.LPCWSTR,
        wintypes.LPCWSTR,
        wintypes.LPCWSTR,
        wintypes.INT,
    ]
    __ShellExecuteW.restype = wintypes.HINSTANCE
    ###

    ### kernal32
    __kernel32 = ctypes.windll.kernel32

    __OpenProcess = (
        lambda accessRights, inherit, handle: UACHandler.__kernel32.OpenProcess(
            accessRights, inherit, handle
        )
    )
    __OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
    __OpenProcess.restype = wintypes.HANDLE

    __CloseHandle = lambda handle: UACHandler.__kernel32.CloseHandle(handle)
    __CloseHandle.argtypes = [wintypes.HANDLE]

    __GetExitCodeProcess = (
        lambda handle, exitCode: UACHandler.__kernel32.GetExitCodeProcess(
            handle, exitCode
        )
    )
    __GetExitCodeProcess.argtypes = [wintypes.HANDLE, ctypes.POINTER(wintypes.DWORD)]
    __GetExitCodeProcess.restype = wintypes.BOOL

    ###

    @staticmethod
    def isAdmin():
        return UACHandler.__shell32.IsUserAnAdmin() == 1

    @staticmethod
    def launchAsAdmin():
        if UACHandler.isAdmin():
            return

        script = sys.argv[0]
        success = UACHandler.__ShellExecuteW(
            None,
            "runas",
            sys.executable,
            f'"{script}"',
            os.path.dirname(script),
            1,  # SW_SHOWNORMAL
        )

        if success <= 32:  # ShellExecute returns >32 on success
            error_code = ctypes.GetLastError()
            raise Exception(
                f"Failed to execute shell command\nWindows Error Code: {error_code}"
            )


class KillInfo:
    @staticmethod
    def __getCaptureGroup(matchObject: re.Match, index=0, default=None):
        if matchObject is None:
            return default

        groups = matchObject.groups()

        if index > len(groups) - 1:
            return default

        return groups[index]

    @staticmethod
    def __get_pName(source: str):
        return KillInfo.__getCaptureGroup(re.search(r"\"(.*)\"", source))

    @staticmethod
    def __get_pid(source: str):
        return KillInfo.__getCaptureGroup(re.search(r"PID (\d+)", source))

    extra: str = None
    pName: str = None
    pid: str = None

    def __init__(self, source: str):
        lines = source.split("\n")

        if len(lines) != 1:
            self.extra = lines[1]

        self.pName = KillInfo.__get_pName(source)
        self.pid = KillInfo.__get_pid(source)


class KillInfoManager:
    __timeStampNew: float = None
    __timeStampOld: float = None
    __lastKilledProcessInfo: KillInfo = None
    total: int = None

    def __init__(self):
        self.total = 0
        self.__timeStampNew = time.time()

    def notifyProcessKilled(self, process: KillInfo):
        self.total += 1

        # the old value is now the current new value
        self.__timeStampOld = self.__timeStampNew
        # the new value is the current process were recieving
        self.__timeStampNew = time.time()
        # also the value shown is the new process were receving cuz thats the one they just killed B)
        self.__lastKilledProcessInfo = process

    def timeSinceLastKilled(self):
        return time.time() - (self.__timeStampOld or 0)

    def totalKilled(self):
        return self.total

    def lastKilled(self):
        return self.__lastKilledProcessInfo

    def __str__(self):

        pid, pName = "NONE", "NONE"
        if self.__lastKilledProcessInfo:
            pid, pName = (
                self.__lastKilledProcessInfo.pid,
                self.__lastKilledProcessInfo.pName,
            )

        return f"Killed {self.total} total processes. Last Killed {repr( pName )}, PID {repr( pid )}. Seconds Since Last Detection: {self.timeSinceLastKilled():.2f}"


class ConsoleWriter:
    last: str = None

    def __init__(self):
        self.startup()

    def startup(self):
        print("Process killer started.")

    def refresh(self, kill_info):
        killStr = str(kill_info)

        # Print the new string with carriage return to overwrite
        print(f"\r{killStr}", end="")

        # If the new string is shorter, pad with spaces to clear the rest of the line
        if self.last is not None and len(self.last) > len(killStr):
            diff = len(self.last) - len(killStr)
            print(" " * diff, end="")

        # Update last for next comparison
        self.last = killStr

        sys.stdout.flush()


class EasterEgg:
    """
    This is an easter egg! ðŸ¤ 
    """


class LockFile:
    __lockname = ".pkillerlockfile"

    @staticmethod
    def getLockFilePath():
        return os.path.join(os.getcwd(), LockFile.__lockname)

    @staticmethod
    def isLocked():
        return os.path.exists(LockFile.getLockFilePath())

    @staticmethod
    def set():
        if LockFile.isLocked():
            return False

        with open(LockFile.getLockFilePath(), "w") as f:
            f.write(str(os.getpid()))

        return True

    @staticmethod
    def release():
        if not LockFile.isLocked():
            return True

        pid = None
        with open(LockFile.getLockFilePath()) as f:
            pid = f.read()

        output = subprocess.getoutput(f"taskkill /f /pid {pid}")

        if "SUCCESS" not in output and "not found" not in output:
            raise Exception(f"Failed to kill task!\n{output}")

        os.remove(LockFile.getLockFilePath())

        return True


isVSCode = os.environ.get("TERM_PROGRAM", False) == "vscode"

if not UACHandler.isAdmin() and not isVSCode:
    UACHandler.launchAsAdmin()
    sys.exit(0)  # Exit immediately after launching elevated process
elif isVSCode:
    LockFile.release()
else:
    print("Waiting for admin process to end...")


try:
    if LockFile.isLocked():
        print("Process Killer Already Running!!")
        print("Close it?")

        match input("[(Y)/N] > "):
            case "N":
                os._exit(0)
            case _:
                LockFile.release()

    LockFile.set()

    killInfoInst = KillInfoManager()
    consoleWriterInst = ConsoleWriter()

    def kill(name: str):
        output = subprocess.getoutput(f"taskkill /f /im {name}")
        return ("SUCCESS" in output, KillInfo(output))

    while True:
        with open(
            os.path.join(os.path.dirname(sys.argv[0]), "processList.txt"),
            "r",
            encoding="utf-8",
        ) as f:
            toKill = f.readlines()

        toKill = list(filter(lambda v: not v.startswith("//"), toKill))

        for item in toKill:
            killed, inst = kill(item)

            if killed:
                killInfoInst.notifyProcessKilled(inst)
                consoleWriterInst.refresh(killInfoInst)

        time.sleep(baud / 1000)

except Exception as e:
    raise e

finally:
    LockFile.release()
